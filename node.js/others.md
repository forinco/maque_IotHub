# API
API 指的是应用程序编程接口（Application Programming Interface），它是一组定义了软件组件之间交互的规范和接口。

API 可以被看作是一种契约，它定义了软件组件之间相互通信的方式，规定了各个组件之间如何传递数据和调用函数等操作。通过 API，软件组件可以实现相互协作，共同完成复杂的任务。

API 通常被用于开发应用程序和网络服务，它提供了一种标准化的接口，使得开发者可以更加轻松地使用和集成各种不同的软件组件。例如，一个 Web 应用程序可以使用 Twitter API 获取用户的推文信息，或者使用 Google Maps API 来实现地图功能。

API 可以是开放的（公开的）或者封闭的（私有的）。开放的 API 可以被任何人使用，而封闭的 API 则只对特定的用户或组织开放。

# v8引擎
V8 引擎是一个由 Google 开发的高性能 JavaScript 引擎，它主要被用于 Google Chrome 浏览器和 Node.js 等 JavaScript 运行环境中。

Node.js 是一个基于 V8 引擎的 `JavaScript` 运行环境，它使用**事件驱动、非阻塞 I/O 模型和单线程事件循环机制**，为开发者提供了一种高效、轻量级的服务器端编程方案。
Node.js 的核心模块是由 C++ 编写的，而其他模块则是由 JavaScript 编写的，这些模块可以被组合和扩展，从而实现各种各样的服务器端应用程序。

Node.js 基于 V8 引擎的优势，具有出色的性能和高效的内存管理能力，可以处理大量的并发连接和高吞吐量的数据流，适合于构建高性能、可扩展的网络应用程序。
# 观察者模式
观察者模式是一种行为型设计模式，它定义了一种对象之间的一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会收到通知并自动更新。

观察者模式中包含两种角色:观察者和被观察.被观察者就是一个可观察的对象,它维护了一组观察者，当自己的状态发生改变时，会通知所有的观察者；观察者则是一个接口，它定义了观察者需要实现的更新方法，当被观察者的状态发生改变时，观察者的更新方法就会被调用。

观察者模式的优点在于它能够实现对象之间的松耦合，被观察者和观察者之间并没有直接的依赖关系，它们之间只是通过一个接口进行通信。这样就使得系统更加灵活，当需要添加新的观察者时，只需要实现观察者接口即可，而不需要修改被观察者的代码。

观察者模式的缺点在于它可能会造成循环依赖的问题，如果被观察者和观察者之间都可以相互观察，那么就会造成循环依赖的问题。此时需要通过设计来解决这个问题，例如使用中介者模式来解耦。
# 使用模块注意
在使用模块时，括号内的引号可以使用单引号或双引号，两者的效果是一样的。

例如，以下两种写法是等价的：

```js
const fs = require('fs');
```

```js
const fs = require("fs");
```

在 JavaScript 中，使用单引号或双引号来表示字符串都是合法的，但是在某些场合下，可能会要求使用一种或另一种引号。例如，在 HTML 中，使用双引号来表示属性值是比较常见的做法，这时在 JavaScript 代码中就需要使用单引号来表示字符串，或者使用转义字符来转义双引号。

总之，使用哪种引号来表示字符串取决于个人的喜好和编码规范。在编写代码时，只需要保持一致即可。
# 读取相对路径
在运行 Node.js 程序时，读取文本文件时的相对路径是相对于当前工作目录的，而不是相对于程序文件所在的目录的。

当前工作目录通常是启动 Node.js 程序时所在的目录，可以通过 `process.cwd()` 方法获取当前工作目录。如果你想要在程序文件所在的目录中读取文件，可以使用 `__dirname` 变量来获取程序文件所在的目录，再使用相对路径来读取文件。
**__dirname** 表示当前执行脚本所在的目录。

例如，假设程序文件所在的目录是 `/Users/username/project/app`，你想要读取同目录下的 `data.txt` 文件，可以这样写：

```js
const path = require('path');
const fs = require('fs');

const filePath = path.join(__dirname, 'data.txt');
fs.readFile(filePath, (err, data) => {
  if (err) throw err;
  console.log(data.toString());
});
```

这里使用了 `path.join()` 方法来拼接绝对路径，保证了读取文件时的路径正确。
# 异步编程
这里的异步编程指的是单线程的异步编程 相比对多线程编程有许多优点:
- 不需要考虑*线程同步* *资源竞争*等问题
- 多线程的线程本身也会有不小的资源消耗 单线程就避免了线程内存的开销
- 也避免多线程之间的频繁切换
## 回调地狱
`promise`对象可以解决这个问题 
`promise`的优点就是可以用一个链式结构把多个异步操作串起来 
`async await`结构更是利用了上述方法的升级版 
`await`底层是基于`promise`和事件循环机制实现的
使用`await`需要要注意的陷阱:
- 不能在全局或者普通函数中直接使用`await`关键字 `await`只适用于异步函数   
